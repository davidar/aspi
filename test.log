>>> % PICK UP A BIG RED BLOCK.
>>> goal_once(holding[big red block])
--> goal_once(holding(A)) :- big(A), red(A), block(A).
apply(pickup(green_cube_1),1).
apply(put_on(green_cube_1,table_front_right),2).
plan_interval(1,1,3).
apply(pickup(big_red),3).
moves(3).
ok.

>>> 
>>> % GRASP THE PYRAMID.
>>> goal(holding[pyramid])
--> goal(holding(A)) :- pyramid(A).
I CAN'T

>>> 
>>> % FIND A BLOCK WHICH IS TALLER THAN THE ONE YOU ARE HOLDING AND PUT IT INTO THE BOX.
>>> :def holding(X) :- holds(holding(X)).
understood.

>>> goal_once(on([block taller_than.holding], box))
--> goal_once(on(B,box)) :- block(B), taller_than(B,A), holding(A).
apply(put_on(big_red,table_back_left),4).
apply(pickup(blue_block),5).
plan_interval(2,4,6).
apply(put_on(blue_block,box),6).
moves(6).
ok.

>>> 
>>> % WHAT DOES THE BOX CONTAIN?
>>> :def holds(above(A,B), TIME) :- holds(on(A,B), TIME).
understood.

>>> :def holds(above(A,C), TIME) :- holds(above(A,B), TIME), holds(above(B,C), TIME).
understood.

>>> :def above(A,B) :- holds(above(A,B)).
understood.

>>> [above.box]
--> show(B) :- above(B,A), box(A).
blue_block.
blue_pyramid.

>>> 
>>> % WHAT IS THE PYRAMID SUPPORTED BY?
>>> :def holds(supports(A,B), TIME) :- holds(on(B,A), TIME).
understood.

>>> :def supports(A,B) :- holds(supports(A,B)).
understood.

>>> [supports[that pyramid]]
--> show(B) :- supports(B,A), that(A), pyramid(A).
box.

>>> 
>>> % HOW MANY BLOCKS ARE NOT IN THE BOX?
>>> [block ~above.box]
--> show(C) :- block(C), not lifted1(C).
    lifted1(B) :- above(B,A), box(A).
big_red.
red_cube.
green_cube_1.
green_cube_2.

>>> 
>>> % IS AT LEAST ONE OF THEM NARROWER THAN THE ONE WHICH I TOLD YOU TO PICK UP?
>>> [that narrower_than.history$goal$holding]
--> show(B) :- that(B), narrower_than(B,A), history(goal(holding(A))).
red_cube.

>>> 
>>> % IS IT SUPPORTED?
>>> [supports.that]
--> show(B) :- supports(B,A), that(A).
table_front_left.

>>> 
>>> % CAN THE TABLE PICK UP BLOCKS?
>>> show(true) :- action(pickup(A,B)), table(A), block(B). \
... show(false) :- not show(true).
false.

>>> 
>>> % CAN A PYRAMID BE SUPPORTED BY A BLOCK?
>>> show(true) :- action(put_on(P,B)), pyramid(P), block(B). \
... show(false) :- not show(true).
true.

>>> 
>>> % CAN A PYRAMID SUPPORT A PYRAMID?
>>> show(true) :- action(put_on(P,Q)), pyramid(P), pyramid(Q). \
... show(false) :- not show(true).
false.

>>> 
>>> % STACK UP TWO PYRAMIDS.
>>> goal_once(on([pyramid], [pyramid]))
--> goal_once(on(A,B)) :- pyramid(A), pyramid(B).
I CAN'T

>>> 
>>> % WILL YOU PLEASE STACK UP BOTH OF THE RED BLOCKS AND EITHER A GREEN CUBE OR A PYRAMID?
>>> :def holds(stack(A,B,C; A,C,B; B,A,C; B,C,A; C,A,B; C,B,A), TIME) :- holds(on(A,B), TIME), holds(on(B,C), TIME), not table(C), C != box.
understood.

>>> goal_once(stack([red block], [red block], [green cube | pyramid]))
--> goal_once(stack(A,B,D)) :- red(A), block(A), red(B), block(B), disjunction1(D).
    disjunction1(C) :- green(C), cube(C).
    disjunction1(C) :- pyramid(C).
apply(pickup(green_pyramid),7).
apply(put_on(green_pyramid,blue_block),8).
apply(pickup(red_cube),9).
apply(put_on(red_cube,green_cube_2),10).
apply(pickup(big_red),11).
plan_interval(11,7,12).
apply(put_on(big_red,red_cube),12).
moves(12).
ok.

>>> 
>>> % WHICH CUBE IS SITTING ON THE TABLE?
>>> :def on(A,B) :- holds(on(A,B)).
understood.

>>> [cube on.table]
--> show(B) :- cube(B), on(B,A), table(A).
green_cube_1.
green_cube_2.

>>> 
>>> % IS THERE A LARGE BLOCK BEHIND A PYRAMID?
>>> :def holds(behind(B,A), TIME) :- holds(above(B,X), TIME), holds(above(A,Y), TIME), table(X), table(Y), holds(behind(X,Y), TIME).
understood.

>>> :def behind(B,A) :- holds(behind(B,A)).
understood.

>>> [large block behind.pyramid]
--> show(B) :- large(B), block(B), behind(B,A), pyramid(A).
blue_block.

>>> 
>>> % PUT A SMALL ONE ONTO THE GREEN CUBE WHICH SUPPORTS A PYRAMID.
>>> goal_once(on([small block], [green cube supports.pyramid]))
--> goal_once(on(A,C)) :- small(A), block(A), green(C), cube(C), supports(C,B), pyramid(B).
already(on(red_cube,green_cube_2)).

>>> 
>>> % PUT THE LITTLEST PYRAMID ON TOP OF IT.
>>> :def that(X) :- history(counter-1, goal(on(X,_))).
understood.

>>> goal_once(on([most(little, pyramid)], [that]))
--> goal_once(on(B,C)) :- little(B,A) : pyramid(A), B != A; pyramid(B), that(C).
apply(pickup(big_red),13).
apply(put_on(big_red,table_back_left),14).
apply(pickup(green_pyramid),15).
plan_interval(15,13,16).
apply(put_on(green_pyramid,red_cube),16).
moves(16).
ok.

>>> 
>>> % DOES THE SHORTEST THING THE TALLEST PYRAMID'S SUPPORT SUPPORTS SUPPORT ANYTHING GREEN?
>>> [green on.most(short, on.supports.most(tall, pyramid))]
--> show(G) :- green(G), on(G,F), short(F,D) : superlative1(D), F != D; superlative1(F).
    superlative1(E) :- on(E,C), supports(C,B), tall(B,A) : pyramid(A), B != A; pyramid(B).
green_pyramid.

>>> 
>>> % WHAT COLOR IS IT?
>>> [colour.supports.that]
--> show(C) :- colour(C,B), supports(B,A), that(A).
red.

>>> 
>>> % HOW MANY THINGS ARE ON TOP OF GREEN CUBES?
>>> [above[green cube]]
--> show(B) :- above(B,A), green(A), cube(A).
red_cube.
red_pyramid.
green_pyramid.

>>> 
>>> % HAD YOU TOUCHED ANY PYRAMID BEFORE YOU PUT THE GREEN ONE ON THE LITTLE CUBE?
>>> :def touched_pyramid_before(P,S) :- pyramid(P), apply(pickup(P),S), S < T-1, green(X), pyramid(X), apply(put_on(X,C),T), small(C), cube(C).
understood.

>>> show(P) :- touched_pyramid_before(P,S).
green_pyramid.

>>> 
>>> % WHEN DID YOU PICK IT UP?
>>> show(goal(G)) :- touched_pyramid_before(P,S), plan_interval(C, T1, T2), T1 <= S, S <= T2, history(C, goal(G)).
goal(stack(red_cube,big_red,green_cube_2)).

>>> 
>>> % WHY?
>>> :def explain(apply(X,S), (apply(A,T), demands(A,F,true)))  :- adds(X,F),    plan_interval(C, T1, T2), T1 <= S, S <= T2, demands(A,F,true),  apply(A,T), S < T, T <= T2, S = 1..now.
understood.

>>> :def explain(apply(X,S), (apply(A,T), demands(A,F,false))) :- deletes(X,F), plan_interval(C, T1, T2), T1 <= S, S <= T2, demands(A,F,false), apply(A,T), S < T, T <= T2, S = 1..now, holds(F, S-1).
understood.

>>> show(R) :- touched_pyramid_before(P,S), explain(apply(pickup(P),S), R).
(apply(put_on(green_pyramid,blue_block),8),demands(put_on(green_pyramid,blue_block),holding(green_pyramid),true)).
(apply(pickup(red_cube),9),demands(pickup(red_cube),on(green_pyramid,red_cube),false)).
(apply(put_on(big_red,red_cube),12),demands(put_on(big_red,red_cube),on(green_pyramid,red_cube),false)).

>>> 
>>> % WHY DID YOU CLEAR OFF THAT CUBE?
>>> show(R) :- it((A, demands(pickup(C),on(Y,C),false))), cube(C), explain(A,R).
(apply(put_on(red_cube,green_cube_2),10),demands(put_on(red_cube,green_cube_2),holding(red_cube),true)).

>>> 
>>> % WHY DID YOU DO THAT?
>>> :def explain(apply(A,T), goal(G)) :- plan_interval(C,S,T), history(C, goal(G)), action(A).
understood.

>>> show(R) :- it((A,D)), explain(A,R).
(apply(pickup(big_red),11),demands(pickup(big_red),holding(red_cube),false)).

>>> show(R) :- it((A,D)), explain(A,R).
(apply(put_on(big_red,red_cube),12),demands(put_on(big_red,red_cube),holding(big_red),true)).

>>> show(R) :- it((A,D)), explain(A,R).
goal(stack(red_cube,big_red,green_cube_2)).

>>> 
>>> % WHY DID YOU DO THAT?
>>> :def explain(goal(G), history(C, goal(G))) :- history(C, goal(G)).
understood.

>>> show(R) :- it(G), explain(G,R).
history(11,goal(stack(red_cube,big_red,green_cube_2))).

>>> 
>>> % HOW DID YOU DO IT?
>>> :def steps(C, apply(A,T)) :- plan_interval(C, T1, T2), apply(A,T), T = T1..T2.
understood.

>>> show(A) :- it(history(C,G)), steps(C,A).
apply(pickup(green_pyramid),7).
apply(put_on(green_pyramid,blue_block),8).
apply(pickup(red_cube),9).
apply(put_on(red_cube,green_cube_2),10).
apply(pickup(big_red),11).
apply(put_on(big_red,red_cube),12).

>>> 
>>> % HOW MANY OBJECTS DID YOU TOUCH WHILE YOU WERE DOING IT?
>>> show(X) :- it(apply(pickup(X), T)).
big_red.
red_cube.
green_pyramid.

>>> 
>>> % WHAT DID THE RED CUBE SUPPORT BEFORE YOU STARTED TO CLEAN IT OFF?
>>> :def cleanoff(X,T) :- apply(pickup(Y), T), holds(on(Y,X), T-1).
understood.

>>> show(X) :- holds(on(X,red_cube),S), S < T, cleanoff(red_cube, T).
green_pyramid.
big_red.

>>> 
>>> % THERE WERE FIVE BLOCKS TO THE LEFT OF THE BOX THEN.
>>> :def holds(left_of(B,A), TIME) :- holds(above(B,X), TIME), holds(above(A,Y), TIME), table(X), table(Y), holds(left_of(X,Y), TIME).
understood.

>>> show(X) :- cleanoff(red_cube,T), block(X), holds(left_of(X,box), T-1).
big_red.
red_cube.

>>> [count(that)]
--> show(B) :- B = #count { A : that(A) }.
2.

>>> 
>>> % PUT THE BLUE PYRAMID ON THE BLOCK IN THE BOX.
>>> goal(on([blue pyramid], [block above.box]))
--> goal(on(A,C)) :- blue(A), pyramid(A), block(C), above(C,B), box(B).
apply(pickup(blue_pyramid),17).
plan_interval(32,17,18).
apply(put_on(blue_pyramid,blue_block),18).
moves(18).
ok.

>>> 
>>> % IS THERE ANYTHING WHICH IS BIGGER THAN EVERY PYRAMID BUT IS NOT AS WIDE AS THE THING THAT SUPPORTS IT?
>>> show(X) :- object(X), bigger_than(X,P) : pyramid(P); holds(on(X,B)), wider_than(B,X).
blue_block.

>>> 
>>> % A "STEEPLE" IS A STACK WHICH CONTAINS TWO GREEN CUBES AND A PYRAMID.
>>> :def holds(steeple, TIME) :- holds(stack(A,B,C), TIME), green(A), cube(A), green(B), cube(B), A != B, pyramid(C).
understood.

>>> 
>>> % ARE THERE ANY STEEPLES NOW?
>>> show(true) :- holds(steeple). \
... show(false) :- not holds(steeple).
false.

>>> 
>>> % BUILD ONE.
>>> goal(steeple).
apply(pickup(red_pyramid),19).
apply(put_on(red_pyramid,big_red),20).
apply(pickup(green_pyramid),21).
apply(put_on(green_pyramid,blue_block),22).
apply(pickup(red_cube),23).
apply(put_on(red_cube,big_red),24).
apply(pickup(green_cube_2),25).
apply(put_on(green_cube_2,green_cube_1),26).
apply(pickup(red_pyramid),27).
plan_interval(35,19,28).
apply(put_on(red_pyramid,green_cube_2),28).
moves(28).
ok.

>>> 
>>> % CALL THE BIGGEST BLOCK "SUPERBLOCK".
>>> :def superblock(B) :- block(B), bigger_than(B,X) : block(X), X != B.
understood.

>>> 
>>> % HAVE YOU PICKED SUPERBLOCK UP SINCE WE BEGAN?
>>> picked_up(X) :- apply(pickup(X),T). \
... show(true) :- picked_up(B), superblock(B). \
... show(false) :- not picked_up(B), superblock(B).
true.

>>> 
>>> % WHY DID YOU DROP IT?
>>> :def explain(A,R) :- apply(A,T), explain(apply(A,T), R).
understood.

>>> :def explain(A, nonexistent) :- action(A), not apply(A,T) : T = 1..now.
understood.

>>> show(R) :- explain(put_on(B,T),R), superblock(B), table(T).
nonexistent.

>>> 
>>> % IS THERE ANYTHING TO THE RIGHT OF THE RED PYRAMID?
>>> :def holds(right_of(A,B), TIME) :- holds(left_of(B,A), TIME).
understood.

>>> :def right_of(A,B) :- holds(right_of(A,B)).
understood.

>>> goal_once(left_of(red_pyramid,box)).
apply(pickup(red_pyramid),29).
plan_interval(38,29,30).
apply(put_on(red_pyramid,table_front_left),30).
moves(30).
ok.

>>> [right_of[red pyramid]]
--> show(B) :- right_of(B,A), red(A), pyramid(A).
box.
blue_block.
green_cube_1.
green_cube_2.
green_pyramid.
blue_pyramid.

>>> 
>>> thanks.
YOU'RE WELCOME!
