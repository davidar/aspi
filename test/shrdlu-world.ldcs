% https://www.uv.es/ivorra/Filosofia/TC/cubos.png

#enum object: red pyramid | green pyramid | blue pyramid | red cube | first green cube | second green cube | large red block | blue block.
#enum location: front left table | front right table | back left table | back right table | box.
#enum colour: red | green | blue.

init: on(first green cube, large red block).
init: on(large red block, front left table).
init: on(green pyramid, red cube).
init: on(red cube, front left table).
init: on(red pyramid, second green cube).
init: on(second green cube, front right table).
init: on(blue pyramid, box).
init: on(box, back right table).
init: on(blue block, back left table).

init: behind(back, front).
init: left_of(left, right).

location: block.
block: cube.
big: large.
little: small.
small: red cube.

colour.red: colour red.
colour.green: colour green.
colour.blue: colour blue.

tall(blue block, large red block).
tall(red pyramid, blue pyramid).
tall(blue pyramid, green pyramid).
tall(red pyramid, red cube).
tall(A,C) :- tall(A,B), tall(B,C).
short(A,B) :- tall(B,A).

big(blue block, pyramid).
big(large, green pyramid).
big(blue block, large red block).
big(large red block, green cube).
big(green cube, red cube).
big(blue pyramid, red pyramid).
big(red pyramid, green pyramid).
big(A,C) :- big(A,B), big(B,C).
small(A,B) :- big(B,A).
little(A,B) :- small(A,B).

wide(box, object).
wide(table, object).
wide(large red block, red cube).
narrow(A,B) :- wide(B,A).

#fluent stack(C ~table ~box, B, A) :- on(A,B), on(B,C).
#fluent above(A,B) :- on(A,B).
#fluent above(A,C) :- above(A,B), above(B,C).
#fluent in(A,B) :- above(A,B).
#fluent contains(A,B) :- in(B,A).
#fluent supports(A,B) :- on(B,A).
#fluent supporter(X) :- supports(X,Y).
#fluent behind(B,A) :- above(B, table X), above(A, table Y), behind(X,Y).
#fluent left_of(B,A) :- above(B, table X), above(A, table Y), left_of(X,Y).
#fluent right_of(A,B) :- left_of(B,A).

#fluent holding(X).
#fluent on(A,B).

cleanoff_at(X,T) :- holds(on(Y,X), T-1), not holds(on(Y,X), T).
cleanoff(cleanoff_at(X,T), X) :- cleanoff_at(X,T).
start_time(T, cleanoff_at(X,T)) :- cleanoff_at(X,T).
